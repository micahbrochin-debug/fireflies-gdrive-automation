require('dotenv').config();
const { FirefliesService } = require('./services/fireflies');
const { LocalGoogleDriveService } = require('./services/localGoogleDrive');
const { FileNameService } = require('./services/fileName');

class CloudLocalAutomation {
  constructor() {
    this.fireflies = new FirefliesService(process.env.FIREFLIES_API_KEY);
    this.gdrive = new LocalGoogleDriveService({
      localPath: process.env.GOOGLE_DRIVE_LOCAL_PATH || "/home/runner/Google Drive",
      targetFolder: process.env.GOOGLE_DRIVE_TARGET_FOLDER || "Customer Call Transcripts"
    });
    this.fileNameService = new FileNameService();
  }

  async processTranscript(transcriptId) {
    try {
      console.log(`🔄 Processing transcript: ${transcriptId}`);
      
      // Fetch transcript details from Fireflies
      const transcript = await this.fireflies.getTranscript(transcriptId);
      if (!transcript) {
        console.error(`❌ Transcript not found: ${transcriptId}`);
        return false;
      }

      // Generate filename with date/time and company name
      const fileName = this.fileNameService.generateFileName(
        transcript.dateString,
        transcript.title,
        transcript.participants
      );

      console.log(`📝 Generated filename: ${fileName}`);

      // Download transcript content and create PDF
      const uploadResult = await this.gdrive.uploadTranscript(
        fileName,
        null, // Content will be generated by the service
        transcript
      );

      console.log(`✅ Successfully saved PDF: ${uploadResult.localPath}`);
      return uploadResult;

    } catch (error) {
      console.error(`❌ Error processing transcript ${transcriptId}:`, error.message);
      return false;
    }
  }

  async processRecentTranscripts(hours = 1) {
    try {
      console.log(`🔍 Checking for transcripts from the last ${hours} hours...`);
      
      const recentTranscripts = await this.fireflies.getRecentTranscripts(hours);
      console.log(`📋 Found ${recentTranscripts.length} recent transcripts`);

      if (recentTranscripts.length === 0) {
        console.log('ℹ️  No new transcripts to process');
        return [];
      }

      const results = [];
      for (const transcript of recentTranscripts) {
        const result = await this.processTranscript(transcript.id);
        results.push({ 
          transcriptId: transcript.id, 
          title: transcript.title,
          fileName: result ? result.name : null,
          success: !!result 
        });
        
        // Add delay between uploads to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      const successful = results.filter(r => r.success).length;
      console.log(`🎉 Processing complete: ${successful}/${results.length} successful`);
      
      // List generated files
      const generatedFiles = results.filter(r => r.success).map(r => r.fileName);
      console.log('📄 Generated PDFs:', generatedFiles);
      
      return results;
    } catch (error) {
      console.error('❌ Error processing recent transcripts:', error);
      return [];
    }
  }

  async testConnection() {
    console.log('🧪 Testing Fireflies connection...');
    
    try {
      const query = `query { user { name email } }`;
      const response = await this.fireflies.client.post('', { query });
      if (response.data.data?.user) {
        console.log('✅ Fireflies API connected:', response.data.data.user.email);
      }
      
      // Test local directory creation
      const testResult = await this.gdrive.testConnection();
      if (testResult) {
        console.log('✅ Local Google Drive directory ready');
      }
      
      return true;
    } catch (error) {
      console.error('❌ Connection test failed:', error.message);
      return false;
    }
  }
}

// For GitHub Actions cloud deployment
async function runCloudAutomation() {
  console.log('🚀 Starting Fireflies to Google Drive Cloud Automation');
  console.log('⏰ Run time:', new Date().toISOString());
  
  const automation = new CloudLocalAutomation();
  
  // Test connections first
  const connected = await automation.testConnection();
  if (!connected) {
    console.error('❌ Connection test failed, exiting...');
    process.exit(1);
  }
  
  // Process recent transcripts
  const hours = parseInt(process.env.LOOKBACK_HOURS) || 1;
  const results = await automation.processRecentTranscripts(hours);
  
  console.log('📊 Final Results:', JSON.stringify(results, null, 2));
  
  // Create summary for GitHub Actions
  const summary = {
    timestamp: new Date().toISOString(),
    processed: results.length,
    successful: results.filter(r => r.success).length,
    failed: results.filter(r => !r.success).length,
    files: results.filter(r => r.success).map(r => r.fileName)
  };
  
  console.log('📋 Summary:', JSON.stringify(summary, null, 2));
  
  // Set GitHub Actions output
  if (process.env.GITHUB_ACTIONS) {
    console.log(`::set-output name=processed::${summary.processed}`);
    console.log(`::set-output name=successful::${summary.successful}`);
    console.log(`::set-output name=files::${summary.files.join(',')}`);
  }
  
  // Exit with appropriate code
  process.exit(summary.failed > 0 ? 1 : 0);
}

// Run if called directly
if (require.main === module) {
  runCloudAutomation().catch(error => {
    console.error('💥 Fatal error:', error);
    process.exit(1);
  });
}

module.exports = { CloudLocalAutomation };